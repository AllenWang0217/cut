{"name":"Magellan","tagline":"The Simple xUnit Implements in Modern C++11.","body":"## 你无法忍受Google Test的9个特性\r\n\r\n### 用例描述必须遵循严格的标识符规则\r\n\r\n这种严格的规则，虽然给Google Test的实现带来了诸多便捷之处，但这给用户造成了很大的负担。尤其当一个用例需要描述一个数学逻辑规则时，用例的表达力将大大折扣。\r\n\r\n```cpp\r\nTEST_F(RobotCleanerTest, at_the_beginning_the_robot_should_be_in_at_the_initial_position)\r\n{\r\n    ASSERT_EQ(Position(0, 0, NORTH), robot.getPosition());\r\n}\r\n```\r\n\r\n### 贯穿着“重复设计”的坏味道\r\n\r\n如下例，每个`TEST_F`用例都要重复一次`RobotCleanerTest`。\r\n\r\n```cpp\r\nstruct RobotCleanerTest : testing::Test\r\n{\r\nprotected:\r\n    RobotCleaner robot;\r\n};\r\n\r\nTEST_F(RobotCleanerTest, at_the_beginning_the_robot_should_be_in_at_the_initial_position)\r\n{\r\n    ASSERT_EQ(Position(0, 0, NORTH), robot.getPosition());\r\n}\r\n\r\nTEST_F(RobotCleanerTest, should_be_face_west_after_turn_left)\r\n{\r\n   robot.turnLeft();\r\n   ASSERT_EQ(Position(0, 0, WEST), robot.getPosition());\r\n}\r\n```\r\n\r\n### Fixture与TEST_F存在隐晦的继承关系\r\n\r\n这也是上例中将`RobotCleaner robot`声明为`protected`的原因。这种隐晦的继承关系，让刚刚入门使用Google Test的人都大吃一惊。\r\n\r\n当然，如果你了解过Google Test的实现技术(`TEST_F`展开后将生成`Fixture`的一个子类，并自动地注册到框架中)，或者已经习惯了他的的设计，这自然不是问题。\r\n\r\n### TEST， TEST_F的设计容易让人误解、误用\r\n\r\n`TEST_F`的第一个参数是`Fixture`的名字。如下例如果被误用为`TEST`，最理想的情况下，则发生编译时错误。如本例所示，编译器将提示`robot`是一个未定义的变量。最坏的情况下是，错误发生在运行时，可能存在没有调用预期的`SetUp/TearDown`的风险。\r\n\r\n```cpp\r\nstruct RobotCleanerTest : testing::Test\r\n{\r\nprotected:\r\n    RobotCleaner robot;\r\n};\r\n\r\nTEST_F(RobotCleanerTest, at_the_beginning_the_robot_should_be_in_at_the_initial_position)\r\n{\r\n    ASSERT_EQ(Position(0, 0, NORTH), robot.getPosition());\r\n}\r\n```\r\n\r\n### 重写SetUp/TearDown时，缺乏Override的保护\r\n\r\nGoogle Test通过在子类中改写`Setup/TearDown`来定制`Fixture`的功能，但程序员往往易于混淆`setUp, Setup, SetUp, set_up`，尤其在C\\+\\+98中，由于缺失`override`的编译时保护，易于让程序员写出违背原意的逻辑代码，这样的错误很可能是运行时错误。\r\n\r\n```cpp\r\nstruct RobotCleanerTest : testing::Test\r\n{\r\n    virtual void Setup()   // 本应该为SetUp\r\n    {\r\n        robot.reset();\r\n    }\r\n\r\nprotected:\r\n    RobotCleaner robot;\r\n};\r\n```\r\n\r\n### 不符合OO的习惯\r\n\r\n每个`TEST_F/TEST`的实现，感觉是一个个游离的函数，是一个典型的过程式设计，通过重复地使用`RobotCleanerTest`而使它们联系在一起，这太过于牵强。\r\n\r\n此外，需要提取函数时，要么将函数提取到父类的`Fixture`中，要么提取到匿名的`namespace`中，物理上隔离非常远，尤其用例数目很多的时候，问题更突出。无论怎么样，Google Test缺乏严格意义上的OO设计。\r\n\r\n```cpp\r\nstruct RobotCleanerTest : testing::Test\r\n{\r\nprotected:\r\n    RobotCleaner robot;\r\n};\r\n\r\nTEST_F(RobotCleanerTest, at_the_beginning_the_robot_should_be_in_at_the_initial_position)\r\n{\r\n    ASSERT_EQ(Position(0, 0, NORTH), robot.getPosition());\r\n}\r\n\r\nTEST_F(RobotCleanerTest, should_be_face_west_after_turn_left_1_times)\r\n{\r\n    robot.turnLeft();\r\n    ASSERT_EQ(Position(0, 0, WEST), robot.getPosition());\r\n}\r\n\r\nTEST_F(RobotCleanerTest, should_be_face_south_after_turn_left_2_times)\r\n{\r\n    robot.turnLeft();\r\n    robot.turnLeft();\r\n    ASSERT_EQ(Position(0, 0, SOUTH), robot.getPosition());\r\n}\r\n\r\nTEST_F(RobotCleanerTest, should_be_face_east_after_turn_left_3_times)\r\n{\r\n    robot.turnLeft();\r\n    robot.turnLeft();\r\n    robot.turnLeft();\r\n    ASSERT_EQ(Position(0, 0, EAST), robot.getPosition());\r\n}\r\n\r\nTEST_F(RobotCleanerTest, should_be_face_north_after_turn_left_4_times)\r\n{\r\n    robot.turnLeft();\r\n    robot.turnLeft();\r\n    robot.turnLeft();\r\n    robot.turnLeft();\r\n    ASSERT_EQ(Position(0, 0, NORTH), robot.getPosition());\r\n}\r\n```\r\n\r\n### 断言违背直觉\r\n\r\n把期望值放在前面，而把实际值放在后面，严重违反了英语的阅读习惯。犹如我讨厌诸如`if (NULL != ptr)`的反人类的代码一样。\r\n\r\n```cpp\r\nASSERT_EQ(Position(0, 0, WEST), robot.getPosition());\r\n```\r\n\r\n### Global级Fixture不能自动发现\r\n\r\n`GlobalEnvironment`需要手动注册到框架，才能被框架发现，而不像`TEST_F, TEST, TEST_G`无需显式地注册，便能被框架自动发现，设计缺乏统一性，一致性。\r\n\r\n```cpp\r\n#include \"gtest/gtest.h\"\r\n\r\nstruct GlobalEnvironment : testing::Environment\r\n{\r\n    virtual void SetUp()\r\n    { ... }\r\n\r\n    virtual void TearDown()\r\n    { ... }\r\n};\r\n\r\nint main(int argc, char** argv)\r\n{\r\n    testing::AddGlobalTestEnvironment(new GlobalEnvironment);\r\n    testing::InitGoogleTest(&argc, argv);\r\n    return RUN_ALL_TESTS();\r\n}\r\n```\r\n\r\n### 断言缺乏可扩展性\r\n\r\n使用Google Test的断言时，你可以在`ASSERT_EQ, ASSERT_NE, ASSERT_TRUE, ASSERT_FALSE`之中做选择。当然你可以认为这无可厚非，但这样的设计最大的问题在于：只能使用框架本身所提供的几个为数不多的断言原语，缺乏可扩展性，或者扩展起来非常困难。\r\n\r\n例如你想增加个一个`ASSERT_NIL`的断言，扩展起来变得非常不自然。\r\n\r\n### 没有理由，就是不喜欢\r\n\r\n在C\\+\\+社区中，有很多人在使用Google Test。这归功于它在平台性移植、部署与安装等方面非常成功，尤其符合微软平台上的C++程序员的胃口；其次，Google Test的`TEST, TEST_F`实现的自动发现机制，相对于CppUnit等框架显得更技高一筹。\r\n\r\n但对于高级别的、骨灰级的C++程序员，是无法容忍上述的Google Test的致命性缺陷的，例如严格的标识符命名规则，这种强制的约束几乎等于杀了他。\r\n\r\n## Magellan：开启新的征程\r\n\r\n### 灵感\r\n\r\nMagellan是一个简单的、可扩展的、使用C\\+\\+11实现的xUnit测试框架。Magellan设计灵感来自于Java社区著名的测试框架JUnit。\r\n\r\n### 安装\r\n\r\n#### GitHub\r\n\r\n- 地址：[https://github.com/horance-liu/magellan](https://github.com/horance-liu/magellan)\r\n- 作者：刘光聪\r\n- Email：[horance@outlook.com](horance@outlook.com)\r\n\r\n#### 编译环境\r\n\r\n支持的平台:\r\n* [MAC OS X] supported\r\n* [Linux] supported\r\n* [Windows] not supported\r\n\r\n支持的编译器:\r\n* [CLANG] 3.4 or later.\r\n* [GCC] 4.8 or later.\r\n* [MSVC] not supported.\r\n\r\n#### 安装CMake\r\n\r\nCMake的下载地址：[http://www.cmake.org](http://www.cmake.org)。\r\n\r\n#### 克隆Magellan\r\n\r\n```bash\r\n$ git clone https://github.com/horance-liu/magellan.git\r\n$ cd magellan\r\n$ git submodule init\r\n$ git submodule update\r\n```\r\n\r\n#### 安装Magellan\r\n\r\n```bash\r\n$ cd magellan\r\n$ mkdir build\r\n$ cd build\r\n$ cmake ..\r\n$ make\r\n$ sudo make install\r\n$ sudo ldconfig\r\n```\r\n\r\n#### 测试Magellan\r\n\r\n```bash\r\n$ cd magellan/build\r\n$ cmake -DENABLE_TEST=on ..\r\n$ make\r\n$ test/magellan-test\r\n$ lib/l0-infra/l0-infra-test\r\n$ lib/hamcrest/hamcrest-test\r\n```\r\n\r\n### 破冰之旅\r\n\r\n##### 物理目录\r\n\r\n```bash\r\nquantity\r\n├── include\r\n│   └── quantity\r\n├── src\r\n│   └── quantity\r\n└── test\r\n│   ├── main.cpp\r\n└── CMakeLists.txt\r\n```\r\n\r\n##### main函数\r\n\r\n```cpp\r\n#include \"magellan/magellan.hpp\"\r\n\r\nint main(int argc, char** argv)\r\n{\r\n    return magellan::run_all_tests(argc, argv);\r\n}\r\n```\r\n\r\n##### CMakeList脚本\r\n\r\n```cmake\r\nproject(quantity)\r\n\r\ncmake_minimum_required(VERSION 2.8)\r\n\r\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++0x\")\r\n\r\ninclude_directories(${CMAKE_CURRENT_SOURCE_DIR}/include)\r\n\r\nfile(GLOB_RECURSE all_files\r\nsrc/*.cpp\r\nsrc/*.cc\r\nsrc/*.c\r\ntest/*.cpp\r\ntest/*.cc\r\ntest/*.c)\r\n\r\nadd_executable(quantity-test ${all_files})\r\n\r\ntarget_link_libraries(quantity-test magellan hamcrest l0-infra)\r\n```\r\n\r\n##### 构建\r\n\r\n```bash\r\n$ mkdir build\r\n$ cd build\r\n$ cmake ..\r\n$ make\r\n```\r\n\r\n##### 运行\r\n\r\n```bash\r\n$ ./quantity-test\r\n\r\n[==========] Running 0 test cases.\r\n[----------] 0 tests from All Tests\r\n[----------] 0 tests from All Tests\r\n\r\n[==========] 0 test cases ran.\r\n[  TOTAL   ] PASS: 0  FAILURE: 0  ERROR: 0  TIME: 0 us\r\n```\r\n\r\n### 体验Magellan\r\n\r\n#### 第一个用例\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\n#include \"quantity/Length.h\"\r\n\r\nUSING_HAMCREST_NS\r\n\r\nFIXTURE(LengthTest)\r\n{\r\n    TEST(\"1 FEET should equal to 12 INCH\")\r\n    {\r\n        ASSERT_THAT(Length(1, FEET), eq(Length(12, INCH)));\r\n    }\r\n};\r\n```\r\n\r\n使用 Magellan,只需要包含 `magellan.hpp` 一个头文件即可。Magellan 使用 Hamcrest 的断言机制,\r\n使得断言更加统一、自然,且具有良好的扩展性;使用 `USING_HAMCREST_NS`,从而可以使用 `eq` 代\r\n替 `hamcrest::eq`,简短明确;除非出现名字冲突,否则推荐使用简写的 `eq`。\r\n\r\n#### Length实现\r\n\r\n```cpp\r\n// quantity/Length.h\r\n#include \"quantity/Amount.h\"\r\n\r\nenum LengthUnit\r\n{\r\n    INCH = 1,\r\n    FEET = 12 * INCH,\r\n};\r\n\r\nstruct Length\r\n{\r\n    Length(Amount amount, LengthUnit unit);\r\n\r\n    bool operator==(const Length& rhs) const;\r\n    bool operator!=(const Length& rhs) const;\r\n\r\nprivate:\r\n    const Amount amountInBaseUnit;\r\n};\r\n```\r\n\r\n```cpp\r\n// quantity/Length.cpp\r\n#include \"quantity/Length.h\"\r\n\r\nLength::Length(Amount amount, LengthUnit unit)\r\n  : amountInBaseUnit(unit * amount)\r\n{\r\n}\r\n\r\nbool Length::operator==(const Length& rhs) const\r\n{\r\n    return amountInBaseUnit == rhs.amountInBaseUnit;\r\n}\r\n\r\nbool Length::operator!=(const Length& rhs) const\r\n{\r\n    return !(*this == rhs);\r\n}\r\n```\r\n\r\n##### 构建\r\n\r\n```bash\r\n$ mkdir build\r\n$ cd build\r\n$ cmake ..\r\n$ make\r\n```\r\n\r\n##### 运行\r\n\r\n```bash\r\n$ ./quantity-test\r\n\r\n[==========] Running 1 test cases.\r\n[----------] 1 tests from All Tests\r\n[----------] 1 tests from LengthTest\r\n[ RUN      ] LengthTest::1 FEET should equal to 12 INCH\r\n[       OK ] LengthTest::1 FEET should equal to 12 INCH(13 us)\r\n[----------] 1 tests from LengthTest\r\n\r\n[----------] 1 tests from All Tests\r\n\r\n[==========] 1 test cases ran.\r\n[  TOTAL   ] PASS: 1  FAILURE: 0  ERROR: 0  TIME: 13 us\r\n```\r\n\r\n### Fixture\r\n\r\nFIXTURE的参数可以是任意的C\\+\\+标识符。一般而言，将其命名为CUT(Class Under Test)的名字即可。根据作用域的大小，Fixture可分为三个类别：独立的Fixture，共享的Fixture，全局的Fixture。\r\n\r\n#### 支持BDD风格\r\n\r\n| xUnit         | BDD           |\r\n| ------------- |---------------|\r\n| FIXTURE       | CONTEXT       |\r\n| SETUP         | BEFORE        |\r\n| TEARDOWN      | AFTER         |\r\n| ASSERT_THAT   | EXPECT        |\r\n\r\n#### 独立的Fixture\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\nFIXTURE(LengthTest)\r\n{\r\n    Length length;\r\n\r\n    SETUP()\r\n    {}\r\n\r\n    TEARDOWN()\r\n    {}\r\n\r\n    TEST(\"length test1\")\r\n    {}\r\n\r\n    TEST(\"length test2\")\r\n    {}\r\n};\r\n```\r\n\r\n执行序列为：\r\n1. `Length` 构造函数\r\n2. `SETUP`\r\n3. `TEST(\"length test1\")`\r\n4. `TEARDOWN`\r\n5. `Length` 析构函数\r\n6. `Length` 构造函数\r\n7. `SETUP`\r\n8. `TEST(\"length test2\")`\r\n9. `TEARDOWN`\r\n10. `Length` 析构函数\r\n\r\n\r\n#### 共享的Fixture\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\nFIXTURE(LengthTest)\r\n{\r\n    Length length;\r\n\r\n    BEFORE_CLASS()\r\n    {}\r\n\r\n    AFTER_CLASS()\r\n    {}\r\n\r\n    BEFORE()\r\n    {}\r\n\r\n    AFTER()\r\n    {}\r\n\r\n    TEST(\"length test1\")\r\n    {}\r\n\r\n    TEST(\"length test2\")\r\n    {}\r\n};\r\n```\r\n\r\n执行序列为：\r\n1. `BEFORE_CLASS`\r\n2. `Length` 构造函数\r\n3. `BEFORE`\r\n4. `TEST(\"length test1\")`\r\n5. `AFTER`\r\n6. `Length` 析构函数\r\n7. `Length` 构造函数\r\n8. `BEFORE`\r\n9. `TEST(\"length test2\")`\r\n10. `AFTER`\r\n11. `Length` 析构函数\r\n12. `AFTER_CLASS`\r\n\r\n#### 全局的Fixture\r\n\r\n有时候需要在所有用例启动之前完成一次性的全局性的配置，在所有用例运行完成之后完成一次性的清理工作。Magellan则使用`BEFORE_ALL`和`AFTER_ALL`两个关键字来支持这样的特性。\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\nBEFORE_ALL(\"before all 1\")\r\n{\r\n}\r\n\r\nBEFORE_ALL(\"before all 2\")\r\n{\r\n}\r\n\r\nAFTER_ALL(\"after all 1\")\r\n{\r\n}\r\n\r\nAFTER_ALL(\"after all 2\")\r\n{\r\n}\r\n```\r\n\r\n`BEFORE_ALL`和`AFTER_ALL`向系统注册`Hook`即可，Magellan便能自动地发现它们，并执行它们。犹如C\\+\\+不能保证各源文件中全局变量初始化的顺序一样，避免在源文件之间的`BEFORE_ALL`和`AFTER_ALL`设计不合理的依赖关系。\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\nFIXTURE(LengthTest)\r\n{\r\n    Length length;\r\n\r\n    BEFORE_CLASS()\r\n    {}\r\n\r\n    AFTER_CLASS()\r\n    {}\r\n\r\n    BEFORE()\r\n    {}\r\n\r\n    AFTER()\r\n    {}\r\n\r\n    TEST(\"length test1\")\r\n    {}\r\n\r\n    TEST(\"length test2\")\r\n    {}\r\n};\r\n```\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\nFIXTURE(VolumeTest)\r\n{\r\n    Volume volume;\r\n\r\n    BEFORE_CLASS()\r\n    {}\r\n\r\n    AFTER_CLASS()\r\n    {}\r\n\r\n    BEFORE()\r\n    {}\r\n\r\n    AFTER()\r\n    {}\r\n\r\n    TEST(\"volume test1\")\r\n    {}\r\n\r\n    TEST(\"volume test1\")\r\n    {}\r\n};\r\n```\r\n\r\nMagellan可能的一个执行序列为：\r\n\r\n1. `BEFORE_ALL(\"before all 1\")`\r\n2. `BEFORE_ALL(\"before all 2\")`\r\n3. `LengthTest::BEFORE_CLASS`\r\n4. `Length`构造函数\r\n5. `LengthTest::BEFORE`\r\n6. `TEST(\"length test1\")`\r\n7. `LengthTest::AFTER`\r\n8. `Length`析构函数\r\n9. `Length`构造函数\r\n10. `LengthTest::BEFORE`\r\n11. `TEST(\"length test2\")`\r\n12. `LengthTest::AFTER`\r\n13. `Length`析构函数\r\n14. `LengthTest::AFTER_CLASS`\r\n15. `VolumeTest::BEFORE_CLASS`\r\n16. `Volume`构造函数\r\n17. `LengthTest::BEFORE`\r\n18. `TEST(\"volume test1\")`\r\n19. `LengthTest::AFTER`\r\n20. `Volume`析构函数\r\n21. `Volume`构造函数\r\n22. `LengthTest::BEFORE`\r\n23. `TEST(\"volume test2\")`\r\n24. `LengthTest::AFTER`\r\n25. `Volume`析构函数\r\n26. `VolumeTest::AFTER_CLASS`\r\n27. `AFTER_ALL(\"after all 2\")`\r\n28. `AFTER_ALL(\"after all 1\")`\r\n\r\n\r\n### 用例设计\r\n\r\n#### 自动标识\r\n\r\nMagellan能够自动地实现测试用例的标识功能，用户可以使用字符串来解释说明测试用例的意图，使得用户在描述用例时更加自然和方便。\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n#include \"quantity/length/Length.h\"\r\n\r\nUSING_HAMCREST_NS\r\n\r\nFIXTURE(LengthTest)\r\n{\r\n    TEST(\"1 FEET should equal to 12 INCH\")\r\n    {\r\n        ASSERT_THAT(Length(1, FEET), eq(Length(12, INCH)));\r\n    }\r\n\r\n    TEST(\"1 YARD should equal to 3 FEET\")\r\n    {\r\n        ASSERT_THAT(Length(1, YARD), eq(Length(3, FEET)));\r\n    }\r\n\r\n    TEST(\"1 MILE should equal to 1760 YARD\")\r\n    {\r\n        ASSERT_THAT(Length(1, MILE), eq(Length(1760, YARD)));\r\n    }\r\n};\r\n```\r\n\r\n#### 面向对象\r\n\r\nMagellan实现xUnit时非常巧妙，使得用户设计用例时更加面向对象。`RobotCleaner robot`在每个用例执行时都将获取一个独立的、全新的实例。\r\n\r\n```cpp\r\n#include \"magellan/magellan.hpp\"\r\n#include \"robot-cleaner/RobotCleaner.h\"\r\n#include \"robot-cleaner/Position.h\"\r\n#include \"robot-cleaner/Instructions.h\"\r\n\r\nUSING_HAMCREST_NS\r\n\r\nFIXTURE(RobotCleanerTest)\r\n{\r\n\tRobotCleaner robot;\r\n\r\n    TEST(\"at the beginning, the robot should be in at the initial position\")\r\n    {\r\n        ASSERT_THAT(robot.getPosition(), is(Position(0, 0, NORTH)));\r\n    }\r\n\r\n    TEST(\"left instruction: 1-times\")\r\n    {\r\n        robot.exec(left());\r\n        ASSERT_THAT(robot.getPosition(), is(Position(0, 0, WEST)));\r\n    }\r\n\r\n    TEST(\"left instruction: 2-times\")\r\n    {\r\n        robot.exec(left());\r\n        robot.exec(left());\r\n        ASSERT_THAT(robot.getPosition(), is(Position(0, 0, SOUTH)));\r\n    }\r\n};\r\n```\r\n\r\n#### 函数提取\r\n\r\n提取的相关子函数，可以直接放在`Fixture`的内部，使得用例与其的距离最近，更加体现类作用域的概念。\r\n\r\n```cpp\r\n#include \"magellan/magellan.hpp\"\r\n#include \"robot-cleaner/RobotCleaner.h\"\r\n#include \"robot-cleaner/Position.h\"\r\n#include \"robot-cleaner/Instructions.h\"\r\n\r\nUSING_HAMCREST_NS\r\n\r\nFIXTURE(RobotCleanerTest)\r\n{\r\n    RobotCleaner robot;\r\n\r\n    void WHEN_I_send_instruction(Instruction* instruction)\r\n    {\r\n        robot.exec(instruction);\r\n    }\r\n\r\n    void AND_I_send_instruction(Instruction* instruction)\r\n    {\r\n        WHEN_I_send_instruction(instruction);\r\n    }\r\n\r\n    void THEN_the_robot_cleaner_should_be_in(const Position& position)\r\n    {\r\n        ASSERT_THAT(robot.getPosition(), is(position));\r\n    }\r\n\r\n    TEST(\"at the beginning\")\r\n    {\r\n        THEN_the_robot_cleaner_should_be_in(Position(0, 0, NORTH));\r\n    }\r\n\r\n    TEST(\"left instruction: 1-times\")\r\n    {\r\n        WHEN_I_send_instruction(left());\r\n        THEN_the_robot_cleaner_should_be_in(Position(0, 0, WEST));\r\n    }\r\n\r\n    TEST(\"left instruction: 2-times\")\r\n    {\r\n        WHEN_I_send_instruction(repeat(left(), 2));\r\n        THEN_the_robot_cleaner_should_be_in(Position(0, 0, SOUTH));\r\n    }\r\n\r\n    TEST(\"left instruction: 3-times\")\r\n    {\r\n        WHEN_I_send_instruction(repeat(left(), 3));\r\n        THEN_the_robot_cleaner_should_be_in(Position(0, 0, EAST));\r\n    }\r\n\r\n    TEST(\"left instruction: 4-times\")\r\n    {\r\n        WHEN_I_send_instruction(repeat(left(), 4));\r\n        THEN_the_robot_cleaner_should_be_in(Position(0, 0, NORTH));\r\n    }\r\n};\r\n```\r\n\r\n### 断言\r\n\r\n#### ASSERT_THAT\r\n\r\nMagellan只支持一种断言原语：`ASSERT_THAT`, 从而避免用户在选择`ASSERT_EQ/ASSERT_NE, ASSERT_TRUE/ASSERT_FALSE`时的困扰，使其断言更加具有统一性，一致性。\r\n\r\n此外，`ASSERT_THAT`使得断言更加具有表达力，它将实际值放在左边，期望值放在右边，更加符合英语习惯。\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\nFIXTURE(CloseToTest)\r\n{\r\n    TEST(\"close to double\")\r\n    {\r\n        ASSERT_THAT(1.0, close_to(1.0, 0.5));\r\n        ASSERT_THAT(0.5, close_to(1.0, 0.5));\r\n        ASSERT_THAT(1.5, close_to(1.0, 0.5));\r\n    }\r\n};\r\n```\r\n\r\n#### Hamcrest\r\n\r\nHamcrest是Java社区一个轻量级的，可扩展的Matcher框架，曾被Kent Beck引入到JUnit框架中，用于增强断言的机制。Magellan引入了Hamcrest的设计，实现了一个C\\+\\+移植版本的Hamcrest，使得Magellang的断言更加具有扩展性和可读性。\r\n\r\n##### anything\r\n\r\n| 匹配器         | 说明           |\r\n| ------------- |---------------|\r\n| anything      | 总是匹配       |\r\n| _             | anything语法糖 |\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\nUSING_HAMCREST_NS\r\n\r\nFIXTURE(AnythingTest)\r\n{\r\n    TEST(\"should always be matched\")\r\n    {\r\n        ASSERT_THAT(1, anything<int>());\r\n        ASSERT_THAT(1u, anything<unsigned int>());\r\n        ASSERT_THAT(1.0, anything<double>());\r\n        ASSERT_THAT(1.0f, anything<float>());\r\n        ASSERT_THAT(false, anything<bool>());\r\n        ASSERT_THAT(true, anything<bool>());\r\n        ASSERT_THAT(nullptr, anything<std::nullptr_t>());\r\n    }\r\n\r\n    TEST(\"should support _ as syntactic sugar\")\r\n    {\r\n        ASSERT_THAT(1u, _(int));\r\n        ASSERT_THAT(1.0f, _(float));\r\n        ASSERT_THAT(false, _(int));\r\n        ASSERT_THAT(nullptr, _(std::nullptr_t));\r\n    }\r\n};\r\n```\r\n\r\n##### 比较器\r\n\r\n| 匹配器         | 说明            |\r\n| ------------- |----------------|\r\n| eq      \t\t| 相等       \t\t|\r\n| ne      \t\t| 不相等          |\r\n| lt      \t\t| 小于       \t\t|\r\n| gt      \t\t| 大于       \t\t|\r\n| le      \t\t| 小于或等于       |\r\n| ge      \t\t| 大于或等于       |\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\nUSING_HAMCREST_NS\r\n\r\nFIXTURE(EqualToTest)\r\n{\r\n    TEST(\"should allow compare to integer\")\r\n    {\r\n        ASSERT_THAT(0xFF, eq(0xFF));\r\n        ASSERT_THAT(0xFF, is(eq(0xFF)));\r\n\r\n        ASSERT_THAT(0xFF, is(0xFF));\r\n        ASSERT_THAT(0xFF == 0xFF, is(true));\r\n    }\r\n\r\n    TEST(\"should allow compare to bool\")\r\n    {\r\n        ASSERT_THAT(true, eq(true));\r\n        ASSERT_THAT(false, eq(false));\r\n    }\r\n\r\n    TEST(\"should allow compare to string\")\r\n    {\r\n        ASSERT_THAT(\"hello\", eq(\"hello\"));\r\n        ASSERT_THAT(\"hello\", eq(std::string(\"hello\")));\r\n        ASSERT_THAT(std::string(\"hello\"), eq(std::string(\"hello\")));\r\n    }\r\n};\r\n\r\nFIXTURE(NotEqualToTest)\r\n{\r\n    TEST(\"should allow compare to integer\")\r\n    {\r\n        ASSERT_THAT(0xFF, ne(0xEE));\r\n\r\n        ASSERT_THAT(0xFF, is_not(0xEE));\r\n        ASSERT_THAT(0xFF, is_not(eq(0xEE)));\r\n        ASSERT_THAT(0xFF != 0xEE, is(true));\r\n    }\r\n\r\n    TEST(\"should allow compare to boolean\")\r\n    {\r\n        ASSERT_THAT(true, ne(false));\r\n        ASSERT_THAT(false, ne(true));\r\n    }\r\n\r\n    TEST(\"should allow compare to string\")\r\n    {\r\n        ASSERT_THAT(\"hello\", ne(\"world\"));\r\n        ASSERT_THAT(\"hello\", ne(std::string(\"world\")));\r\n        ASSERT_THAT(std::string(\"hello\"), ne(std::string(\"world\")));\r\n    }\r\n};\r\n```\r\n\r\n##### 修饰器\r\n\r\n| 匹配器         | 说明            |\r\n| ------------- |----------------|\r\n| is      \t\t| 可读性装饰器     |\r\n| is_not        | 可读性装饰器     |\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\nUSING_HAMCREST_NS\r\n\r\nFIXTURE(IsNotTest)\r\n{\r\n    TEST(\"integer\")\r\n    {\r\n        ASSERT_THAT(0xFF, is_not(0xEE));\r\n        ASSERT_THAT(0xFF, is_not(eq(0xEE)));\r\n    }\r\n\r\n    TEST(\"string\")\r\n    {\r\n        ASSERT_THAT(\"hello\", is_not(\"world\"));\r\n        ASSERT_THAT(\"hello\", is_not(eq(\"world\")));\r\n\r\n        ASSERT_THAT(\"hello\", is_not(std::string(\"world\")));\r\n        ASSERT_THAT(std::string(\"hello\"), is_not(std::string(\"world\")));\r\n    }\r\n};\r\n```\r\n\r\n#####  空指针\r\n\r\n| 匹配器         | 说明            |\r\n| ------------- |----------------|\r\n| nil      \t\t| 空指针          |\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\nUSING_HAMCREST_NS\r\n\r\nFIXTURE(NilTest)\r\n{\r\n    TEST(\"equal_to\")\r\n    {\r\n        ASSERT_THAT(nullptr, eq(nullptr));\r\n        ASSERT_THAT(0, eq(NULL));\r\n        ASSERT_THAT(NULL, eq(NULL));\r\n        ASSERT_THAT(NULL, eq(0));\r\n    }\r\n\r\n    TEST(\"is\")\r\n    {\r\n        ASSERT_THAT(nullptr, is(nullptr));\r\n        ASSERT_THAT(nullptr, is(eq(nullptr)));\r\n\r\n        ASSERT_THAT(0, is(0));\r\n        ASSERT_THAT(NULL, is(NULL));\r\n        ASSERT_THAT(0, is(NULL));\r\n        ASSERT_THAT(NULL, is(0));\r\n    }\r\n\r\n    TEST(\"nil\")\r\n    {\r\n        ASSERT_THAT((void*)NULL, nil());\r\n        ASSERT_THAT((void*)0, nil());\r\n        ASSERT_THAT(nullptr, nil());\r\n    }\r\n};\r\n```\r\n\r\n##### 字符串\r\n\r\n| 匹配器           \t\t      | 说明 \t\t\t\t          |\r\n| ----------------------------- |----------------------------|\r\n| contains_string               | 断言是否包含子串  \t\t    |\r\n| contains_string_ignoring_case | 忽略大小写，断言是否包含子      |\r\n| starts_with                   | 断言是否以该子串开头           |\r\n| starts_with_ignoring_case     | 忽略大小写，断言是否以该子串开头 |\r\n| ends_with                     | 断言是否以该子串结尾  \t\t   |\r\n| ends_with_ignoring_case       | 忽略大小写，断言是否以该子串结尾 |\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n\r\nUSING_HAMCREST_NS\r\n\r\nFIXTURE(StartsWithTest)\r\n{\r\n    TEST(\"case sensitive\")\r\n    {\r\n        ASSERT_THAT(\"ruby-cpp\", starts_with(\"ruby\"));\r\n        ASSERT_THAT(\"ruby-cpp\", is(starts_with(\"ruby\")));\r\n\r\n        ASSERT_THAT(std::string(\"ruby-cpp\"), starts_with(\"ruby\"));\r\n        ASSERT_THAT(\"ruby-cpp\", starts_with(std::string(\"ruby\")));\r\n        ASSERT_THAT(std::string(\"ruby-cpp\"), starts_with(std::string(\"ruby\")));\r\n    }\r\n\r\n    TEST(\"ignoring case\")\r\n    {\r\n        ASSERT_THAT(\"ruby-cpp\", starts_with_ignoring_case(\"Ruby\"));\r\n        ASSERT_THAT(\"ruby-cpp\", is(starts_with_ignoring_case(\"Ruby\")));\r\n\r\n        ASSERT_THAT(std::string(\"ruby-cpp\"), starts_with_ignoring_case(\"RUBY\"));\r\n        ASSERT_THAT(\"Ruby-Cpp\", starts_with_ignoring_case(std::string(\"rUBY\")));\r\n        ASSERT_THAT(std::string(\"RUBY-CPP\"), starts_with_ignoring_case(std::string(\"ruby\")));\r\n    }\r\n};\r\n```\r\n\r\n##### 浮点数\r\n\r\n| 匹配器    | 说明 \t\t\t\t   |\r\n| ---------|----------------------|\r\n| close_to | 断言浮点数近似等于  \t|\r\n| nan      | 断言浮点数不是一个数字   |\r\n\r\n```cpp\r\n#include <magellan/magellan.hpp>\r\n#include <math.h>\r\n\r\nUSING_HAMCREST_NS\r\n\r\nFIXTURE(IsNanTest)\r\n{\r\n    TEST(\"double\")\r\n    {\r\n        ASSERT_THAT(sqrt(-1.0), nan());\r\n        ASSERT_THAT(sqrt(-1.0), is(nan()));\r\n\r\n        ASSERT_THAT(1.0/0.0,  is_not(nan()));\r\n        ASSERT_THAT(-1.0/0.0, is_not(nan()));\r\n    }\r\n};\r\n```\r\n\r\n### 程序选项\r\n\r\n```cpp\r\nTestOptions::TestOptions() : desc(\"magellan\")\r\n{\r\n    desc.add({\r\n        {\"help,     h\",   \"help message\"},\r\n        {\"filter,   f\",   \"--filter=pattern\"},\r\n        {\"color,    c\",   \"--color=[yes|no]\"},\r\n        {\"xml,      x\",   \"print test result into XML file\"},\r\n        {\"list,     l\",   \"list all tests without running them\"},\r\n        {\"progress, p\",   \"print test result in progress bar\"},\r\n        {\"verbose,  v\",   \"verbosely list tests processed\"},\r\n        {\"repeat,   r\",   \"how many times to repeat each test\"}\r\n    });\r\n    \r\n    // default value\r\n    options[\"color\"]  = \"yes\";\r\n    options[\"repeat\"] = \"1\";\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}